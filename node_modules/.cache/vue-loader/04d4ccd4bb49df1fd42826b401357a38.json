{"remainingRequest":"/Users/wjcwjc/Desktop/大学/大三上/2020301人立方/hcube-b/hcube-client/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/wjcwjc/Desktop/大学/大三上/2020301人立方/hcube-b/hcube-client/node_modules/@jiaminghi/data-view/lib/components/waterLevelPond/src/main.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/wjcwjc/Desktop/大学/大三上/2020301人立方/hcube-b/hcube-client/node_modules/@jiaminghi/data-view/lib/components/waterLevelPond/src/main.vue","mtime":499162500000},{"path":"/Users/wjcwjc/Desktop/大学/大三上/2020301人立方/hcube-b/hcube-client/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/wjcwjc/Desktop/大学/大三上/2020301人立方/hcube-b/hcube-client/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/wjcwjc/Desktop/大学/大三上/2020301人立方/hcube-b/hcube-client/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/wjcwjc/Desktop/大学/大三上/2020301人立方/hcube-b/hcube-client/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCB7IHV1aWQgfSBmcm9tICcuLi8uLi8uLi91dGlsL2luZGV4JwoKaW1wb3J0IHsgZGVlcE1lcmdlIH0gZnJvbSAnQGppYW1pbmdoaS9jaGFydHMvbGliL3V0aWwvaW5kZXgnCgppbXBvcnQgeyBkZWVwQ2xvbmUgfSBmcm9tICdAamlhbWluZ2hpL2MtcmVuZGVyL2xpYi9wbHVnaW4vdXRpbCcKCmltcG9ydCBDUmVuZGVyIGZyb20gJ0BqaWFtaW5naGkvYy1yZW5kZXInCgpleHBvcnQgZGVmYXVsdCB7CiAgbmFtZTogJ0R2V2F0ZXJMZXZlbFBvbmQnLAogIHByb3BzOiB7CiAgICBjb25maWc6IE9iamVjdCwKICAgIGRlZmF1bHQ6ICgpID0+ICh7fSkKICB9LAogIGRhdGEgKCkgewogICAgY29uc3QgaWQgPSB1dWlkKCkKICAgIHJldHVybiB7CiAgICAgIGdyYWRpZW50SWQ6IGB3YXRlci1sZXZlbC1wb25kLSR7aWR9YCwKCiAgICAgIGRlZmF1bHRDb25maWc6IHsKICAgICAgICAvKioKICAgICAgICAgKiBAZGVzY3JpcHRpb24gRGF0YQogICAgICAgICAqIEB0eXBlIHtBcnJheTxOdW1iZXI+fQogICAgICAgICAqIEBkZWZhdWx0IGRhdGEgPSBbXQogICAgICAgICAqIEBleGFtcGxlIGRhdGEgPSBbNjAsIDQwXQogICAgICAgICAqLwogICAgICAgIGRhdGE6IFtdLAogICAgICAgIC8qKgogICAgICAgICAqIEBkZXNjcmlwdGlvbiBTaGFwZSBvZiB3YW50ZXIgbGV2ZWwgcG9uZAogICAgICAgICAqIEB0eXBlIHtTdHJpbmd9CiAgICAgICAgICogQGRlZmF1bHQgc2hhcGUgPSAncmVjdCcKICAgICAgICAgKiBAZXhhbXBsZSBzaGFwZSA9ICdyZWN0JyB8ICdyb3VuZFJlY3QnIHwgJ3JvdW5kJwogICAgICAgICAqLwogICAgICAgIHNoYXBlOiAncmVjdCcsCiAgICAgICAgLyoqCiAgICAgICAgICogQGRlc2NyaXB0aW9uIFdhdGVyIHdhdmUgbnVtYmVyCiAgICAgICAgICogQHR5cGUge051bWJlcn0KICAgICAgICAgKiBAZGVmYXVsdCB3YXZlTnVtID0gMwogICAgICAgICAqLwogICAgICAgIHdhdmVOdW06IDMsCiAgICAgICAgLyoqCiAgICAgICAgICogQGRlc2NyaXB0aW9uIFdhdGVyIHdhdmUgaGVpZ2h0IChweCkKICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfQogICAgICAgICAqIEBkZWZhdWx0IHdhdmVIZWlnaHQgPSA0MAogICAgICAgICAqLwogICAgICAgIHdhdmVIZWlnaHQ6IDQwLAogICAgICAgIC8qKgogICAgICAgICAqIEBkZXNjcmlwdGlvbiBXYXZlIG9wYWNpdHkKICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfQogICAgICAgICAqIEBkZWZhdWx0IHdhdmVPcGFjaXR5ID0gMC40CiAgICAgICAgICovCiAgICAgICAgd2F2ZU9wYWNpdHk6IDAuNCwKICAgICAgICAvKioKICAgICAgICAgKiBAZGVzY3JpcHRpb24gQ29sb3JzIChoZXh8cmdifHJnYmF8Y29sb3Iga2V5d29yZHMpCiAgICAgICAgICogQHR5cGUge0FycmF5PFN0cmluZz59CiAgICAgICAgICogQGRlZmF1bHQgY29sb3JzID0gWycjMDBCQUZGJywgJyMzREU3QzknXQogICAgICAgICAqIEBleGFtcGxlIGNvbG9ycyA9IFsnIzAwMCcsICdyZ2IoMCwgMCwgMCknLCAncmdiYSgwLCAwLCAwLCAxKScsICdyZWQnXQogICAgICAgICAqLwogICAgICAgIGNvbG9yczogWycjM0RFN0M5JywgJyMwMEJBRkYnXSwKICAgICAgICAvKioKICAgICAgICAgKiBAZGVzY3JpcHRpb24gRm9ybWF0dGVyCiAgICAgICAgICogQHR5cGUge1N0cmluZ30KICAgICAgICAgKiBAZGVmYXVsdCBmb3JtYXR0ZXIgPSAne3ZhbHVlfSUnCiAgICAgICAgICovCiAgICAgICAgZm9ybWF0dGVyOiAne3ZhbHVlfSUnCiAgICAgIH0sCgogICAgICBtZXJnZWRDb25maWc6IHt9LAoKICAgICAgcmVuZGVyZXI6IG51bGwsCgogICAgICBzdmdCb3JkZXJHcmFkaWVudDogW10sCgogICAgICBkZXRhaWxzOiAnJywKCiAgICAgIHdhdmVzOiBbXSwKCiAgICAgIGFuaW1hdGlvbjogZmFsc2UKICAgIH0KICB9LAogIGNvbXB1dGVkOiB7CiAgICByYWRpdXMgKCkgewogICAgICBjb25zdCB7IHNoYXBlIH0gPSB0aGlzLm1lcmdlZENvbmZpZwoKICAgICAgaWYgKHNoYXBlID09PSAncm91bmQnKSByZXR1cm4gJzUwJScKCiAgICAgIGlmIChzaGFwZSA9PT0gJ3JlY3QnKSByZXR1cm4gJzAnCgogICAgICBpZiAoc2hhcGUgPT09ICdyb3VuZFJlY3QnKSByZXR1cm4gJzEwcHgnCgogICAgICByZXR1cm4gJzAnCiAgICB9LAogICAgc2hhcGUgKCkgewogICAgICBjb25zdCB7IHNoYXBlIH0gPSB0aGlzLm1lcmdlZENvbmZpZwoKICAgICAgaWYgKCFzaGFwZSkgcmV0dXJuICdyZWN0JwoKICAgICAgcmV0dXJuIHNoYXBlCiAgICB9CiAgfSwKICB3YXRjaDogewogICAgY29uZmlnICgpIHsKICAgICAgY29uc3QgeyBjYWxjRGF0YSwgcmVuZGVyZXIgfSA9IHRoaXMKCiAgICAgIHJlbmRlcmVyLmRlbEFsbEdyYXBoKCkKCiAgICAgIHRoaXMud2F2ZXMgPSBbXQoKICAgICAgc2V0VGltZW91dChjYWxjRGF0YSwgMCkKICAgIH0KICB9LAogIG1ldGhvZHM6IHsKICAgIGluaXQgKCkgewogICAgICBjb25zdCB7IGluaXRSZW5kZXIsIGNvbmZpZywgY2FsY0RhdGEgfSA9IHRoaXMKCiAgICAgIGluaXRSZW5kZXIoKQoKICAgICAgaWYgKCFjb25maWcpIHJldHVybgoKICAgICAgY2FsY0RhdGEoKQogICAgfSwKICAgIGluaXRSZW5kZXIgKCkgewogICAgICBjb25zdCB7ICRyZWZzIH0gPSB0aGlzCgogICAgICB0aGlzLnJlbmRlcmVyID0gbmV3IENSZW5kZXIoJHJlZnNbJ3dhdGVyLXBvbmQtbGV2ZWwnXSkKICAgIH0sCiAgICBjYWxjRGF0YSAoKSB7CiAgICAgIGNvbnN0IHsgbWVyZ2VDb25maWcsIGNhbGNTdmdCb3JkZXJHcmFkaWVudCwgY2FsY0RldGFpbHMgfSA9IHRoaXMKCiAgICAgIG1lcmdlQ29uZmlnKCkKCiAgICAgIGNhbGNTdmdCb3JkZXJHcmFkaWVudCgpCgogICAgICBjYWxjRGV0YWlscygpCgogICAgICBjb25zdCB7IGFkZFdhdmUsIGFuaW1hdGlvbldhdmUgfSA9IHRoaXMKCiAgICAgIGFkZFdhdmUoKQoKICAgICAgYW5pbWF0aW9uV2F2ZSgpCiAgICB9LAogICAgbWVyZ2VDb25maWcgKCkgewogICAgICBjb25zdCB7IGNvbmZpZywgZGVmYXVsdENvbmZpZyB9ID0gdGhpcwoKICAgICAgdGhpcy5tZXJnZWRDb25maWcgPSBkZWVwTWVyZ2UoZGVlcENsb25lKGRlZmF1bHRDb25maWcsIHRydWUpLCBjb25maWcpCiAgICB9LAogICAgY2FsY1N2Z0JvcmRlckdyYWRpZW50ICgpIHsKICAgICAgY29uc3QgeyBjb2xvcnMgfSA9IHRoaXMubWVyZ2VkQ29uZmlnCgogICAgICBjb25zdCBjb2xvck51bSA9IGNvbG9ycy5sZW5ndGgKCiAgICAgIGNvbnN0IGNvbG9yT2Zmc2V0R2FwID0gMTAwIC8gKGNvbG9yTnVtIC0gMSkKCiAgICAgIHRoaXMuc3ZnQm9yZGVyR3JhZGllbnQgPSBjb2xvcnMubWFwKChjLCBpKSA9PiBbY29sb3JPZmZzZXRHYXAgKiBpLCBjXSkKICAgIH0sCiAgICBjYWxjRGV0YWlscyAoKSB7CiAgICAgIGNvbnN0IHsgZGF0YSwgZm9ybWF0dGVyIH0gPSB0aGlzLm1lcmdlZENvbmZpZwoKICAgICAgaWYgKCFkYXRhLmxlbmd0aCkgewogICAgICAgIHRoaXMuZGV0YWlscyA9ICcnCgogICAgICAgIHJldHVybgogICAgICB9CgogICAgICBjb25zdCBtYXhWYWx1ZSA9IE1hdGgubWF4KC4uLmRhdGEpCgogICAgICB0aGlzLmRldGFpbHMgPSBmb3JtYXR0ZXIucmVwbGFjZSgne3ZhbHVlfScsIG1heFZhbHVlKQogICAgfSwKICAgIGFkZFdhdmUgKCkgewogICAgICBjb25zdCB7IHJlbmRlcmVyLCBnZXRXYXZlU2hhcGVzLCBnZXRXYXZlU3R5bGUsIGRyYXdlZCB9ID0gdGhpcwoKICAgICAgY29uc3Qgc2hhcGVzID0gZ2V0V2F2ZVNoYXBlcygpCiAgICAgIGNvbnN0IHN0eWxlID0gZ2V0V2F2ZVN0eWxlKCkKCiAgICAgIHRoaXMud2F2ZXMgPSBzaGFwZXMubWFwKHNoYXBlID0+IHJlbmRlcmVyLmFkZCh7CiAgICAgICAgbmFtZTogJ3Ntb290aGxpbmUnLAogICAgICAgIGFuaW1hdGlvbkZyYW1lOiAzMDAsCiAgICAgICAgc2hhcGUsCiAgICAgICAgc3R5bGUsCiAgICAgICAgZHJhd2VkCiAgICAgIH0pKQogICAgfSwKICAgIGdldFdhdmVTaGFwZXMgKCkgewogICAgICBjb25zdCB7IG1lcmdlZENvbmZpZywgcmVuZGVyZXIsIG1lcmdlT2Zmc2V0IH0gPSB0aGlzCgogICAgICBjb25zdCB7IHdhdmVOdW0sIHdhdmVIZWlnaHQsIGRhdGEgfSA9IG1lcmdlZENvbmZpZwoKICAgICAgY29uc3QgW3csIGhdID0gcmVuZGVyZXIuYXJlYQoKICAgICAgY29uc3QgcG9pbnRzTnVtID0gd2F2ZU51bSAqIDQgKyA0CgogICAgICBjb25zdCBwb2ludFhHYXAgPSB3IC8gd2F2ZU51bSAvIDIKCiAgICAgIHJldHVybiBkYXRhLm1hcCh2ID0+IHsKICAgICAgICBsZXQgcG9pbnRzID0gbmV3IEFycmF5KHBvaW50c051bSkuZmlsbCgwKS5tYXAoKGZvbywgaikgPT4gewogICAgICAgICAgY29uc3QgeCA9IHcgLSBwb2ludFhHYXAgKiBqCgogICAgICAgICAgY29uc3Qgc3RhcnRZID0gKDEgLSB2IC8gMTAwKSAqIGgKCiAgICAgICAgICBjb25zdCB5ID0gaiAlIDIgPT09IDAgPyBzdGFydFkgOiBzdGFydFkgLSB3YXZlSGVpZ2h0CgogICAgICAgICAgcmV0dXJuIFt4LCB5XQogICAgICAgIH0pCgogICAgICAgIHBvaW50cyA9IHBvaW50cy5tYXAocCA9PiBtZXJnZU9mZnNldChwLCBbcG9pbnRYR2FwICogMiwgMF0pKQoKICAgICAgICByZXR1cm4geyBwb2ludHMgfQogICAgICB9KQogICAgfSwKICAgIG1lcmdlT2Zmc2V0IChbeCwgeV0sIFtveCwgb3ldKSB7CiAgICAgIHJldHVybiBbeCArIG94LCB5ICsgb3ldCiAgICB9LAogICAgZ2V0V2F2ZVN0eWxlICgpIHsKICAgICAgY29uc3QgeyByZW5kZXJlciwgbWVyZ2VkQ29uZmlnIH0gPSB0aGlzCgogICAgICBjb25zdCBoID0gcmVuZGVyZXIuYXJlYVsxXQoKICAgICAgcmV0dXJuIHsKICAgICAgICBncmFkaWVudENvbG9yOiBtZXJnZWRDb25maWcuY29sb3JzLAogICAgICAgIGdyYWRpZW50VHlwZTogJ2xpbmVhcicsCiAgICAgICAgZ3JhZGllbnRQYXJhbXM6IFswLCAwLCAwLCBoXSwKICAgICAgICBncmFkaWVudFdpdGg6ICdmaWxsJywKICAgICAgICBvcGFjaXR5OiBtZXJnZWRDb25maWcud2F2ZU9wYWNpdHksCiAgICAgICAgdHJhbnNsYXRlOiBbMCwgMF0KICAgICAgfQogICAgfSwKICAgIGRyYXdlZCAoeyBzaGFwZTogeyBwb2ludHMgfSB9LCB7IGN0eCwgYXJlYSB9KSB7CiAgICAgIGNvbnN0IGZpcnN0UG9pbnQgPSBwb2ludHNbMF0KICAgICAgY29uc3QgbGFzdFBvaW50ID0gcG9pbnRzLnNsaWNlKC0xKVswXQoKICAgICAgY29uc3QgaCA9IGFyZWFbMV0KCiAgICAgIGN0eC5saW5lVG8obGFzdFBvaW50WzBdLCBoKQogICAgICBjdHgubGluZVRvKGZpcnN0UG9pbnRbMF0sIGgpCgogICAgICBjdHguY2xvc2VQYXRoKCkKCiAgICAgIGN0eC5maWxsKCkKICAgIH0sCiAgICBhc3luYyBhbmltYXRpb25XYXZlIChyZXBlYXQgPSAxKSB7CiAgICAgIGNvbnN0IHsgd2F2ZXMsIHJlbmRlcmVyLCBhbmltYXRpb24gfSA9IHRoaXMKCiAgICAgIGlmIChhbmltYXRpb24pIHJldHVybgoKICAgICAgdGhpcy5hbmltYXRpb24gPSB0cnVlCgogICAgICBjb25zdCB3ID0gcmVuZGVyZXIuYXJlYVswXQoKICAgICAgd2F2ZXMuZm9yRWFjaChncmFwaCA9PiB7CiAgICAgICAgZ3JhcGguYXR0cignc3R5bGUnLCB7IHRyYW5zbGF0ZTogWzAsIDBdIH0pCgogICAgICAgIGdyYXBoLmFuaW1hdGlvbignc3R5bGUnLCB7CiAgICAgICAgICB0cmFuc2xhdGU6IFt3LCAwXQogICAgICAgIH0sIHRydWUpCiAgICAgIH0pCgogICAgICBhd2FpdCByZW5kZXJlci5sYXVuY2hBbmltYXRpb24oKQoKICAgICAgdGhpcy5hbmltYXRpb24gPSBmYWxzZQoKICAgICAgaWYgKCFyZW5kZXJlci5ncmFwaHMubGVuZ3RoKSByZXR1cm4KCiAgICAgIHRoaXMuYW5pbWF0aW9uV2F2ZShyZXBlYXQgKyAxKQogICAgfQogIH0sCiAgbW91bnRlZCAoKSB7CiAgICBjb25zdCB7IGluaXQgfSA9IHRoaXMKCiAgICBpbml0KCkKICB9LAogIGJlZm9yZURlc3Ryb3kgKCkgewogICAgY29uc3QgeyByZW5kZXJlciB9ID0gdGhpcwoKICAgIHJlbmRlcmVyLmRlbEFsbEdyYXBoKCkKCiAgICB0aGlzLndhdmVzID0gW10KICB9Cn0K"},{"version":3,"sources":["main.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0CA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA","file":"main.vue","sourceRoot":"node_modules/@jiaminghi/data-view/lib/components/waterLevelPond/src","sourcesContent":["<template>\n  <div class=\"dv-water-pond-level\">\n    <svg v-if=\"renderer\">\n      <defs>\n        <linearGradient :id=\"gradientId\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\">\n          <stop v-for=\"lc in svgBorderGradient\" :key=\"lc[0]\"\n            :offset=\"lc[0]\"\n            :stop-color=\"lc[1]\" />\n        </linearGradient>\n      </defs>\n\n      <text\n        v-if=\"renderer\"\n        :stroke=\"`url(#${gradientId})`\"\n        :fill=\"`url(#${gradientId})`\"\n        :x=\"renderer.area[0] / 2 + 8\"\n        :y=\"renderer.area[1] / 2 + 8\"\n      >\n        {{ details }}\n      </text>\n\n      <ellipse v-if=\"!shape || shape === 'round'\"\n        :cx=\"renderer.area[0] / 2 + 8\"\n        :cy=\"renderer.area[1] / 2 + 8\"\n        :rx=\"renderer.area[0] / 2 + 5\"\n        :ry=\"renderer.area[1] / 2 + 5\"\n        :stroke=\"`url(#${gradientId})`\" />\n\n      <rect v-else\n        x=\"2\" y=\"2\"\n        :rx=\"shape === 'roundRect' ? 10 : 0\"\n        :ry=\"shape === 'roundRect' ? 10 : 0\"\n        :width=\"renderer.area[0] + 12\"\n        :height=\"renderer.area[1] + 12\"\n        :stroke=\"`url(#${gradientId})`\" />\n    </svg>\n\n    <canvas ref=\"water-pond-level\" :style=\"`border-radius: ${radius};`\" />\n  </div>\n</template>\n\n<script>\nimport { uuid } from '../../../util/index'\n\nimport { deepMerge } from '@jiaminghi/charts/lib/util/index'\n\nimport { deepClone } from '@jiaminghi/c-render/lib/plugin/util'\n\nimport CRender from '@jiaminghi/c-render'\n\nexport default {\n  name: 'DvWaterLevelPond',\n  props: {\n    config: Object,\n    default: () => ({})\n  },\n  data () {\n    const id = uuid()\n    return {\n      gradientId: `water-level-pond-${id}`,\n\n      defaultConfig: {\n        /**\n         * @description Data\n         * @type {Array<Number>}\n         * @default data = []\n         * @example data = [60, 40]\n         */\n        data: [],\n        /**\n         * @description Shape of wanter level pond\n         * @type {String}\n         * @default shape = 'rect'\n         * @example shape = 'rect' | 'roundRect' | 'round'\n         */\n        shape: 'rect',\n        /**\n         * @description Water wave number\n         * @type {Number}\n         * @default waveNum = 3\n         */\n        waveNum: 3,\n        /**\n         * @description Water wave height (px)\n         * @type {Number}\n         * @default waveHeight = 40\n         */\n        waveHeight: 40,\n        /**\n         * @description Wave opacity\n         * @type {Number}\n         * @default waveOpacity = 0.4\n         */\n        waveOpacity: 0.4,\n        /**\n         * @description Colors (hex|rgb|rgba|color keywords)\n         * @type {Array<String>}\n         * @default colors = ['#00BAFF', '#3DE7C9']\n         * @example colors = ['#000', 'rgb(0, 0, 0)', 'rgba(0, 0, 0, 1)', 'red']\n         */\n        colors: ['#3DE7C9', '#00BAFF'],\n        /**\n         * @description Formatter\n         * @type {String}\n         * @default formatter = '{value}%'\n         */\n        formatter: '{value}%'\n      },\n\n      mergedConfig: {},\n\n      renderer: null,\n\n      svgBorderGradient: [],\n\n      details: '',\n\n      waves: [],\n\n      animation: false\n    }\n  },\n  computed: {\n    radius () {\n      const { shape } = this.mergedConfig\n\n      if (shape === 'round') return '50%'\n\n      if (shape === 'rect') return '0'\n\n      if (shape === 'roundRect') return '10px'\n\n      return '0'\n    },\n    shape () {\n      const { shape } = this.mergedConfig\n\n      if (!shape) return 'rect'\n\n      return shape\n    }\n  },\n  watch: {\n    config () {\n      const { calcData, renderer } = this\n\n      renderer.delAllGraph()\n\n      this.waves = []\n\n      setTimeout(calcData, 0)\n    }\n  },\n  methods: {\n    init () {\n      const { initRender, config, calcData } = this\n\n      initRender()\n\n      if (!config) return\n\n      calcData()\n    },\n    initRender () {\n      const { $refs } = this\n\n      this.renderer = new CRender($refs['water-pond-level'])\n    },\n    calcData () {\n      const { mergeConfig, calcSvgBorderGradient, calcDetails } = this\n\n      mergeConfig()\n\n      calcSvgBorderGradient()\n\n      calcDetails()\n\n      const { addWave, animationWave } = this\n\n      addWave()\n\n      animationWave()\n    },\n    mergeConfig () {\n      const { config, defaultConfig } = this\n\n      this.mergedConfig = deepMerge(deepClone(defaultConfig, true), config)\n    },\n    calcSvgBorderGradient () {\n      const { colors } = this.mergedConfig\n\n      const colorNum = colors.length\n\n      const colorOffsetGap = 100 / (colorNum - 1)\n\n      this.svgBorderGradient = colors.map((c, i) => [colorOffsetGap * i, c])\n    },\n    calcDetails () {\n      const { data, formatter } = this.mergedConfig\n\n      if (!data.length) {\n        this.details = ''\n\n        return\n      }\n\n      const maxValue = Math.max(...data)\n\n      this.details = formatter.replace('{value}', maxValue)\n    },\n    addWave () {\n      const { renderer, getWaveShapes, getWaveStyle, drawed } = this\n\n      const shapes = getWaveShapes()\n      const style = getWaveStyle()\n\n      this.waves = shapes.map(shape => renderer.add({\n        name: 'smoothline',\n        animationFrame: 300,\n        shape,\n        style,\n        drawed\n      }))\n    },\n    getWaveShapes () {\n      const { mergedConfig, renderer, mergeOffset } = this\n\n      const { waveNum, waveHeight, data } = mergedConfig\n\n      const [w, h] = renderer.area\n\n      const pointsNum = waveNum * 4 + 4\n\n      const pointXGap = w / waveNum / 2\n\n      return data.map(v => {\n        let points = new Array(pointsNum).fill(0).map((foo, j) => {\n          const x = w - pointXGap * j\n\n          const startY = (1 - v / 100) * h\n\n          const y = j % 2 === 0 ? startY : startY - waveHeight\n\n          return [x, y]\n        })\n\n        points = points.map(p => mergeOffset(p, [pointXGap * 2, 0]))\n\n        return { points }\n      })\n    },\n    mergeOffset ([x, y], [ox, oy]) {\n      return [x + ox, y + oy]\n    },\n    getWaveStyle () {\n      const { renderer, mergedConfig } = this\n\n      const h = renderer.area[1]\n\n      return {\n        gradientColor: mergedConfig.colors,\n        gradientType: 'linear',\n        gradientParams: [0, 0, 0, h],\n        gradientWith: 'fill',\n        opacity: mergedConfig.waveOpacity,\n        translate: [0, 0]\n      }\n    },\n    drawed ({ shape: { points } }, { ctx, area }) {\n      const firstPoint = points[0]\n      const lastPoint = points.slice(-1)[0]\n\n      const h = area[1]\n\n      ctx.lineTo(lastPoint[0], h)\n      ctx.lineTo(firstPoint[0], h)\n\n      ctx.closePath()\n\n      ctx.fill()\n    },\n    async animationWave (repeat = 1) {\n      const { waves, renderer, animation } = this\n\n      if (animation) return\n\n      this.animation = true\n\n      const w = renderer.area[0]\n\n      waves.forEach(graph => {\n        graph.attr('style', { translate: [0, 0] })\n\n        graph.animation('style', {\n          translate: [w, 0]\n        }, true)\n      })\n\n      await renderer.launchAnimation()\n\n      this.animation = false\n\n      if (!renderer.graphs.length) return\n\n      this.animationWave(repeat + 1)\n    }\n  },\n  mounted () {\n    const { init } = this\n\n    init()\n  },\n  beforeDestroy () {\n    const { renderer } = this\n\n    renderer.delAllGraph()\n\n    this.waves = []\n  }\n}\n</script>"]}]}